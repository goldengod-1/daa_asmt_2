<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="with=device-width, initial-scale=1.0">
		<title>CS F364 Documentation</title>
		<link rel="stylesheet" href="./Pages/static/style.css">
		<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
		<style>
			ul{
				color: white;
			}
		</style>
	</head>
	<body>
		<section class="header">
			<nav>
				<a href="Documentation.html"><img src="./Pages/static/images/logo.png"></a>
				<div class="nav-links">
					<ul>
						<li><a href="Documentation.html">HOME</a></li>
                        <li><a href="About.html">ABOUT</a></li>
						<li><a href="Aim.html">AIM</a></li>
						<li><a href="Classes.html">CLASSES</a></li>
						<li><a href="Functions.html">FUNCTIONS</a></li>
						<li><a href="Outputs.html">COMPARATIVE ANALYSIS</a></li>
						<li><a href="Thoughts.html">COMPLEXITY ANALYSIS</a></li>
						<li><a href="Vis.html">VISUALISATION</a></li>
						<!-- <li><a href="http://127.0.0.1:5501/index.html">SECONDARY STRUCTURE</a></li> -->
					</ul>
				</div>
			</nav>
		<div class="functions_text">
			<h1 style="margin-left: 38vw;">Recurrence relation</h1>
			<p>
			\[ OPT(i, j) = \max(OPT(i, j - 1), \max(1 + OPT(i, t - 1) + OPT(t + 1, j - 1))) \]
			</p>
			<h1>Timing Analysis</h1>
			<p>
			1. <strong>Base Case:</strong> The base case for the recurrence relation is when ( i â‰¥ j-4 ). In this case, OPT(i, j) = 0 because it's not possible to form a valid secondary structure with fewer than 4 bases.
			</p>
			<p>
			2. <strong>Recursive Case:</strong> For ( i < j-4 ), we need to consider two options:
			<ul style="margin-left: 50px;">
				<li><strong>Option 1:</strong> If the base j does not pair with any other base, then the optimal secondary structure for the substring <em>bi</em><sub>i+1</sub> ... <em>b</em><sub>j-1</sub> is the same as the optimal structure for the substring <em>b</em><sub>i</sub> <em>b</em><sub>i+1</sub> ... <em>b</em><sub>j-2</sub>, i.e., OPT(i, j) = OPT(i, j-1).</li>
				<li><strong>Option 2:</strong> If the base j pairs with some base t < j - 4, then we need to consider splitting the substring <em>b</em><sub>i</sub> <em>b</em><sub>i+1</sub> ... <em>b</em><sub>j</sub> into two independent sub-problems:
					<ul style="margin-left: 35px;">
						<li>The first sub-problem deals with the substring <em>b</em><sub>i</sub> <em>b</em><sub>i+1</sub> ... <em>b</em><sub>t-1</sub>, which can be solved by OPT(i, t-1).</li>
						<li>The second sub-problem deals with the substring <em>b</em><sub>t+1</sub> <em>b</em><sub>t+2</sub> ... <em>b</em><sub>j-1</sub>, which can be solved by OPT(t+1, j-1).</li>
						<li>Additionally, we add 1 to account for the pairing of bases j and t, so the total score becomes 1 + OPT(i, t-1) + OPT(t+1, j-1).</li>
					</ul>
				</li>
			</ul>
			</p>
			

			<p>
			3. <strong>Choose the Maximum:</strong> Finally, we choose the maximum between Option 1 and Option 2 to obtain the optimal solution for the sub-problem OPT(i, j).
			</p>
			<p>
			The time complexity of solving this recurrence relation depends on the number of sub-problems we need to compute. Since each sub-problem OPT(i, j) depends on sub-problems OPT(i, j-1) and OPT(i, t-1) for some t < j - 4, and each sub-problem is computed only once, the total number of sub-problems is O(n^2) , where n is the length of the input sequence and evaluating the recurrence in each takes O(n) time.
			Therefore, the running time of this algorithm is O(n^3).<br/><br/>
			<img src="./Pages/static/images/Time_Analysis.png" alt="Runtime" width="700" height="350"
			style="margin-left: 25vw;">

			
			</p>

<h1>Conclusion</h1>
<p>
We have successfully implemented the required algorithm and have formed an efficient code to find the optimal pairings in the RNA Secondary Structure.
</p>


            <!-- <a href="About.html" class="button4">Thank You!</a> -->
        </div>
	</section> 
	</body>
</html>